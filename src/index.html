<html>
  <head>
    <meta charset="UTF-8" />
    <title>Line Plot</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      .gridlines line {
        stroke: #bbb;
      }

      .gridlines .domain {
        stroke: none;
      }

      .flex-container {
        display: flex;
      }

      .padding {
        margin-left: 5;
        margin-right: 5;
      }

      .window-container {
        display: inline-block;
        margin: 10px;
        text-align: center;
      }

      .window-display {
        font-size: 24px;
        padding: 10px;
        border: 1px solid #ccc;
        width: 60px;
        user-select: none;
        background-color: #f9f9f9;
        border-radius: 5px;
        margin-bottom: 5px;
      }

      .button {
        font-size: 16px;
        padding: 5px 10px;
        margin: 2px;
        cursor: pointer;
        border-radius: 5px;
        background-color: #ccc;
      }

      .button:active {
        background-color: #aaa;
      }
    </style>
  </head>

  <body>
    <h1>Reid's Spotify Stats</h1>
    <h2>Listening Trends</h2>
    <div class="flex-container padding">
      <div>
        <svg id="titleSvg" height="100" width=""></svg>
        <svg
          id="lineplot"
          height="500"
          width="1000"
          style="margin-bottom: 50px"
        ></svg>
      </div>
      <div style="flex-grow: 1; gap: 20px">
        <!-- Select Metric -->
        <div>
          <label for="metricSelect">Select Metric: </label>
          <select id="metricSelect"></select>
        </div>

        <!-- Instructions -->
        <div id="instructions">
          <p>
            <strong>Instructions:</strong><br />
            Select the <u>start</u> and <u>end</u> of the interval. <br />
            The start cannot go below <b>2015</b>, and the end cannot go above
            <b>2024</b>.
          </p>
        </div>

        <!-- Start and End Windows -->
        <div>
          <div id="startWindowContainer" class="window-container"></div>
          <div id="endWindowContainer" class="window-container"></div>
        </div>
        <br />
      </div>
    </div>

    <h2>Top Songs</h2>
    <div>
      <label for="yearSelect">Select Year: </label>
      <select id="yearSelect"></select>
    </div>
    <svg id="barchart" height="400" width="800">
      <text
        id="label"
        x="590"
        y="5"
        text-anchor="end"
        alignment-baseline="hanging"
      ></text>
    </svg>

    <script>
      /* Chart area */

      const svg = d3.select("svg#lineplot");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margins = { top: 10, right: 220, bottom: 70, left: 70 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      let annotations = svg.append("g").attr("id", "annotations");
      let chartArea = svg
        .append("g")
        .attr("transform", `translate(${margins.left},${margins.top})`);
      let colorScale = d3.scaleOrdinal(d3.schemeCategory10);

      d3.csv("reid_final_data.csv").then((data) => {
        const timeParser = d3.timeParse("%Y-%m-%d %H:%M:%S%Z");

        data.forEach((d, i) => {
          d["ts"] = timeParser(d["ts"]);
        })

        console.log(data)

        const dataWithMetricsCols = data.map(function(d) { return {
          ts: d.ts,
          acousticness: d.acousticness,
          danceability: d.danceability,
          energy: d.energy
        }})

        console.log(dataWithMetricsCols)

        const yearData = d3.group(data, (d) => d3.timeFormat("%Y")(d.ts)); // group data by year
        console.log(yearData)

        const monthlyMetrics = d3.rollup(dataWithMetricsCols, (v) => d3.mean(v), (d) => d3.timeFormat("%Y-%m")(d.ts)); // group data by year
        console.log(monthlyMetrics)

        const monthData = d3.group(data, (d) => d3.timeFormat("%Y-%m")(d.ts)); // group data by year
        console.log(monthData)

        // Step 1: Convert data to correct type + gather monthly data
        let monthlyData = {};
        data.forEach((d, i) => {
          d["danceability"] = Number(d["danceability"]);
          d["energy"] = Number(d["energy"]);
          // d["ts"] = timeParser(d["ts"]);

          const month = d["ts"].getMonth();
          const year = d["ts"].getFullYear();
          const currEnergy = d["energy"];
          const currDance = d["danceability"];

          /* if year not in dictionary (null), initialize as empty obj */
          if (!monthlyData[year]) {
            monthlyData[year] = {};
          }

          /* Only initialize the month if it has data */
          if (!monthlyData[year][month]) {
            monthlyData[year][month] = {
              count: 0,
              energySum: 0,
              danceSum: 0,
            };
          }

          monthlyData[year][month].count += 1;
          monthlyData[year][month].energySum += currEnergy;
          monthlyData[year][month].danceSum += currDance;
        });

        // Step 2: Calculate averages and create condensedData
        let condensedData = {};
        for (const year in monthlyData) {
          condensedData[year] = [];

          for (const month in monthlyData[year]) {
            const monthData = monthlyData[year][month];

            if (monthData.count > 0) {
              const date = new Date(year, month);

              condensedData[year].push({
                date: date,
                danceability: monthData.danceSum / monthData.count,
                energy: monthData.energySum / monthData.count,
              });
            }
          }
        }

        console.log("condensedData:");
        console.log(condensedData);

        function updateChart(inputData, metric) {
          // y axis - danceability
          console.log(inputData);
          console.log(metric);
          const danceExtent = d3.extent(inputData, (d) => d[metric]);
          const danceScale = d3
            .scaleLinear()
            .domain(danceExtent)
            .range([chartHeight, 0]);

          let leftAxis = d3.axisLeft(danceScale);
          let leftGridlines = d3
            .axisLeft(danceScale)
            .tickSize(-chartWidth - 10)
            .tickFormat("");

          // Clear previous annotations, lines, circles
          d3.select("#annotations").selectAll("*").remove();
          d3.select("#lineplot").selectAll("path").remove();
          d3.select("#lineplot").selectAll("circle").remove();

          annotations
            .append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${margins.left - 10},${margins.top})`)
            .call(leftAxis);

          annotations
            .append("g")
            .attr("class", "y gridlines")
            .attr("transform", `translate(${margins.left - 10},${margins.top})`)
            .call(leftGridlines);

          annotations
            .append("text")
            .attr(
              "transform",
              `translate(${margins.left - 45},${
                chartHeight / 2 + margins.top + 20
              }) rotate(${-90})`
            )
            .text(`${capitalizeFirstLetter(selectedMetric)}`);

          //  x axis - date
          /* abbreviated month-year format*/
          const monthYearFormat = d3.timeFormat("%b '%y");
          const dateExtent = d3.extent(inputData, (d) => d.date);
          const dateScale = d3
            .scaleTime()
            .domain(dateExtent)
            .range([0, chartWidth]);

          let bottomAxis = d3.axisBottom(dateScale).tickFormat(monthYearFormat);
          let bottomGridlines = d3
            .axisBottom(dateScale)
            .tickSize(-chartHeight - 10)
            .tickFormat("");

          annotations
            .append("g")
            .attr("class", "x axis")
            .attr(
              "transform",
              `translate(${margins.left},${chartHeight + margins.top + 10})`
            )
            .call(bottomAxis)
            .selectAll("text")
            .each(function (_, i) {
              if (i % 2 !== 0) d3.select(this).remove();
            });
          /* https://stackoverflow.com/questions/38921226/show-every-other-tick-label-on-d3-time-axis*/

          annotations
            .append("g")
            .attr("class", "x gridlines")
            .attr(
              "transform",
              `translate(${margins.left},${chartHeight + margins.top + 10})`
            )
            .call(bottomGridlines);

          annotations
            .append("text")
            .text("Dates")
            .attr(
              "transform",
              `translate(${chartWidth / 2 + 15},${
                chartHeight + margins.top + 45
              })`
            );

          // line generator
          var lineGen = d3
            .line()
            .x((d) => dateScale(d.date))
            .y((d) => danceScale(d[metric]))
            .curve(d3.curveMonotoneX);

          chartArea
            .selectAll(".line")
            .data([inputData])
            .join(
              (enter) =>
                enter
                  .append("path")
                  .attr("class", "line")
                  .attr("fill", "none")
                  .attr("stroke", "steelblue")
                  .attr("stroke-width", 3)
                  .attr("d", lineGen),
              (update) => update.transition().duration(750).attr("d", lineGen),
              (exit) => exit.remove()
            );

          // add circles
          chartArea
            .selectAll("circle")
            .data(inputData, (d) => d.date)
            .join(
              (enter) =>
                enter
                  .append("circle")
                  .attr("r", 3)
                  .attr("fill", "navy")
                  .attr("cx", (d) => dateScale(d.date))
                  .attr("cy", (d) => danceScale(d[metric]))
                  .attr("opacity", 0)
                  .transition()
                  .duration(750)
                  .attr("opacity", 1),
              (update) =>
                update
                  .transition()
                  .duration(750)
                  .attr("cx", (d) => dateScale(d.date))
                  .attr("cy", (d) => danceScale(d[metric])),
              (exit) =>
                exit.transition().duration(750).attr("opacity", 0).remove()
            );

          const titleSvg = d3.select("svg#titleSvg");
          titleSvg.selectAll(".chart-title").remove();

          titleSvg
            .append("text")
            .attr("class", "chart-title")
            .attr("x", 430)
            .attr("y", 40)
            .attr("text-anchor", "middle")
            .style("font-size", "24px")
            .style("font-weight", "bold")
            .text(
              `${capitalizeFirstLetter(selectedMetric)} Patterns in One Year`
            );

          // add the caption
          titleSvg
            .append("text")
            .attr("class", "chart-title")
            .attr("x", 450)
            .attr("y", 80)
            .attr("text-anchor", "middle")
            .style("font-size", "14px")
            .text(
              `Trends in ${capitalizeFirstLetter(
                selectedMetric
              )} levels of songs Reid listened to in one year.`
            );
        }

        /* Function to flatten multiple years into a 1D array*/
        intervalData = [];
        function dataForInterval(start, end) {
          // Clear intervalData to start fresh
          intervalData = [];

          for (const yearStr of Object.keys(condensedData)) {
            const year = Number(yearStr);

            if (year >= start && year <= end) {
              intervalData = intervalData.concat(condensedData[year]);
            }
          }
        }

        const metricSelect = d3.select("#metricSelect");
        metricSelect
          .selectAll("option")
          .data(Array.from(["danceability", "energy"]))
          .enter()
          .append("option")
          .text((d) => d)
          .attr("value", (d) => d);

        var selectedMetric = metricSelect.property("value");

        metricSelect.on("change", function () {
          selectedMetric = this.value;

          updateChart(intervalData, selectedMetric);
        });

        /*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
        /* Year interval windows & buttons */
        let startYear = 2015;
        let endYear = 2024;

        //update the displayed value
        function updateDisplay(container, value) {
          container.select(".window-display").text(value);
        }

        // create the window with increment and decrement buttons
        function createYearWindow(
          containerId,
          initialValue,
          onIncrement,
          onDecrement
        ) {
          const container = d3.select(containerId);

          // display area
          container
            .append("div")
            .attr("class", "window-display")
            .text(initialValue);

          // increment button
          container
            .append("button")
            .attr("class", "button")
            .text("▲")
            .on("click", onIncrement);

          // decrement button
          container
            .append("button")
            .attr("class", "button")
            .text("▼")
            .on("click", onDecrement);
        }

        // startWindow handlers
        createYearWindow(
          "#startWindowContainer",
          startYear,
          () => {
            if (startYear < endYear) {
              startYear++;
              updateDisplay(d3.select("#startWindowContainer"), startYear);
              /* reset interval data*/
              console.log("Start window increment");
              console.log(`start year: ${startYear}`);
              dataForInterval(startYear, endYear);
              updateChart(intervalData, selectedMetric);
            }
          },
          () => {
            if (startYear > 2015) {
              startYear--;
              updateDisplay(d3.select("#startWindowContainer"), startYear);
              console.log("Start window decrement");
              console.log(`start year: ${startYear}`);
              dataForInterval(startYear, endYear);
              updateChart(intervalData, selectedMetric);
            }
          }
        );

        // endWindow handlers
        createYearWindow(
          "#endWindowContainer",
          endYear,
          () => {
            if (endYear < 2024) {
              endYear++;
              updateDisplay(d3.select("#endWindowContainer"), endYear);
              console.log("End window increment");
              console.log(`end year: ${endYear}`);
              dataForInterval(startYear, endYear);
              updateChart(intervalData, selectedMetric);
            }
          },
          () => {
            if (endYear > startYear) {
              endYear--;
              updateDisplay(d3.select("#endWindowContainer"), endYear);
              console.log("End window decrement");
              console.log(`end year: ${endYear}`);
              dataForInterval(startYear, endYear);
              updateChart(intervalData, selectedMetric);
            }
          }
        );

        // https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript
        function capitalizeFirstLetter(val) {
          return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }

        /*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

        /* initial chart rendering*/
        dataForInterval(startYear, endYear);
        console.log(intervalData)
        updateChart(intervalData, selectedMetric);

        // BAR CHART


        const yearSelect = d3.select("#yearSelect");
        yearSelect
          .selectAll("option")
          .data(
            Array.from(yearData.keys()).sort(function (a, b) {
              return b - a;
            })
          )
          .enter()
          .append("option")
          .text((d) => d)
          .attr("value", (d) => d);

        yearSelect.on("change", function () {
          const selectedYear = this.value;
          updateBarChart(selectedYear);
        });

        function updateBarChart(year) {
          const filteredData = yearData.get(year) || [];
          const songCounts = d3.rollup(
            filteredData,
            (v) => v.length,
            (d) => d.track
          );

          const top5Songs = Array.from(songCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

          const yScale = d3
            .scaleBand()
            .domain(top5Songs.map((d) => d[0]))
            .range([0, barChartHeight])
            .padding(0.2);

          const xScale = d3
            .scaleLinear()
            .domain([0, d3.max(top5Songs, (d) => d[1])])
            .range([0, barChartWidth]);

          barChartArea.selectAll("rect").remove();
          barAnnotations.selectAll(".bar-axis").remove();
          barChartArea.selectAll(".bar-text").remove();

          let bottomAxis = d3.axisBottom(xScale);
          barAnnotations
            .append("g")
            .attr("class", "bar-axis x-axis")
            .attr(
              "transform",
              `translate(${barMargins.left},${barChartHeight + barMargins.top})`
            )
            .call(bottomAxis);

          barAnnotations
            .append("text")
            .text("Number of Listens")
            .attr(
              "transform",
              `translate(${barChartWidth / 2 + 15},${
                barChartHeight + barMargins.top + 45
              })`
            );

          let leftAxis = d3.axisLeft(yScale).tickValues([]);
          barAnnotations
            .append("g")
            .attr("class", "bar-axis y-axis")
            .attr(
              "transform",
              `translate(${barMargins.left},${barMargins.top})`
            )
            .call(leftAxis);

          barAnnotations
            .append("text")
            .attr(
              "transform",
              `translate(${margins.left - 45},${
                barChartHeight / 2 + barMargins.top + 20
              }) rotate(${-90})`
            )
            .text("Song");

          // draw bars
          barChartArea
            .selectAll("rect")
            .data(top5Songs)
            .enter()
            .append("rect")
            .attr("y", (d) => yScale(d[0]))
            // .attr("x", (d) => xScale(d[1]))
            .attr("height", yScale.bandwidth())
            // .attr("width", (d) => barChartWidth - xScale(d[1]))
            .attr("width", (d) => xScale(d[1]))
            .attr("fill", "steelblue")
            .attr("opacity", 0.5);
          // .append("g")
          // .append("text")
          // .attr("x", (d) => xScale(d[1]))
          // .attr("y", (d) => yScale(d[0]))
          // .text((d) => d[0])

          barChartArea
            .selectAll(".bar-text")
            .data(top5Songs)
            .join("text")
            .attr("class", "bar-text")
            .attr("x", 5)
            .attr("y", (d) => yScale(d[0]) + 18)
            .text((d) => {
              const name = d[0];
              const count = d[1];
              const barWidth = xScale(count);

              // Temporary text element to measure width
              const tempText = barSvg
                .append("text")
                .text(name)
                .style("visibility", "hidden");

              /* https://stackoverflow.com/questions/21990857/d3-js-how-to-get-the-computed-width-and-height-for-an-arbitrary-element */
              let textWidth = tempText.node().getBBox().width;
              tempText.remove();

              if (textWidth > barWidth - 10) {
                let truncated = name;

                while (textWidth > barWidth - 10) {
                  const lastSpace = truncated.lastIndexOf(" ");
                  if (lastSpace === -1) break; // No spaces left, stop truncating

                  // Remove last word
                  truncated = truncated.substring(0, lastSpace);

                  // Recalculate width
                  const tempText = barSvg
                    .append("text")
                    .text(truncated + "...")
                    .style("visibility", "hidden");

                  textWidth = tempText.node().getBBox().width;
                  tempText.remove();
                }

                return truncated + "...";
              }

              return name; // No truncation needed
            });

          // .text((d) => d[0]);
          // .text(top5Songs.forEach((element, index) => { "index + .  + element[0]" }))

          barChartArea.selectAll(".bar-text").raise();
          barChartArea
            .selectAll(".bar-text")
            .on("mouseover", function (event, d) {
              const fullName = d[0];
              console.log(`fullName: ${fullName}`);
              d3.select("#label").text(fullName);
              console.log("mouseover");
            });
          barChartArea.selectAll(".bar-text").on("mouseout", function () {
            d3.select("#label").text("");
            console.log("mouseout");
          });
        }

        // initialize bar chart with the first year
        const initialYear = Array.from(yearData.keys())[0];
        yearSelect.property("value", initialYear);
        updateBarChart(initialYear);
      });

      // Nicole Bar Graph
      const barSvg = d3.select("svg#barchart");
      const barWidth = barSvg.attr("width");
      const barHeight = barSvg.attr("height");
      const barMargins = { top: 10, right: 30, bottom: 70, left: 40 };
      const barChartWidth = barWidth - barMargins.left - barMargins.right;
      const barChartHeight = barHeight - barMargins.top - barMargins.bottom;

      let barChartArea = barSvg
        .append("g")
        .attr("transform", `translate(${barMargins.left},${barMargins.top})`);

      let barAnnotations = barSvg.append("g").attr("id", "barAnnotations");
    </script>
  </body>
</html>
